{"version":3,"file":"3303.aa882f54b76cf7cd14af.js?v=aa882f54b76cf7cd14af","mappings":"gLAAA,SAASA,EAAWC,GAClB,OAAO,IAAIC,OAAO,MAAQD,EAAME,KAAK,OAAS,QAAS,IACzD,CAEA,IAAIC,EAAe,CACjB,UAAW,UAAW,SAAU,SAChC,WAAY,WAAY,WAAY,WAAY,UAAW,aAAc,SACzE,OAAQ,QAAS,SAAU,OAAQ,QAAS,SAC5C,QAAS,QAAS,SAAU,SAAU,SAAU,SAAU,UAAW,UAAW,WAAY,WAC5F,SAAU,UAAW,MAAO,WAE9B,IAAIC,EAAWL,EAAWI,GAE1B,IAAIE,EAAc,IAAIJ,OAAO,iCAE7B,SAASK,EAAUC,GAEjB,GAAIA,EAAOC,WAAY,OAAO,KAG9B,GAAID,EAAOE,MAAM,MAAO,CACtBF,EAAOG,YACP,MAAO,SACT,CAGA,GAAIH,EAAOE,MAAM,aAAc,OAAQ,CACrC,GAAIF,EAAOE,MAAM,wBACf,MAAO,SACT,GAAIF,EAAOE,MAAM,mCACf,MAAO,SACT,GAAIF,EAAOE,MAAM,8BACf,MAAO,QACX,CAGA,GAAIF,EAAOE,MAAM,mBAAoB,CAAE,MAAO,QAAU,CACxD,GAAIF,EAAOE,MAAM,mBAAoB,CAAE,MAAO,QAAU,CAGxD,GAAIF,EAAOE,MAAML,GAAW,CAAE,MAAO,SAAW,CAChD,GAAIG,EAAOE,MAAMJ,GAAc,CAAE,MAAO,UAAY,CAGpDE,EAAOI,OACP,OAAO,IACT,CAEO,MAAMC,EAAW,CACtBC,KAAM,WACNC,MAAOR,EACPS,aAAc,CACZC,aAAcb,G","sources":["webpack://@jupyterlab/application-top/./node_modules/@codemirror/legacy-modes/mode/protobuf.js"],"sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\", \"i\");\n};\n\nvar keywordArray = [\n  \"package\", \"message\", \"import\", \"syntax\",\n  \"required\", \"optional\", \"repeated\", \"reserved\", \"default\", \"extensions\", \"packed\",\n  \"bool\", \"bytes\", \"double\", \"enum\", \"float\", \"string\",\n  \"int32\", \"int64\", \"uint32\", \"uint64\", \"sint32\", \"sint64\", \"fixed32\", \"fixed64\", \"sfixed32\", \"sfixed64\",\n  \"option\", \"service\", \"rpc\", \"returns\"\n];\nvar keywords = wordRegexp(keywordArray);\n\nvar identifiers = new RegExp(\"^[_A-Za-z\\xa1-\\uffff][_A-Za-z0-9\\xa1-\\uffff]*\");\n\nfunction tokenBase(stream) {\n  // whitespaces\n  if (stream.eatSpace()) return null;\n\n  // Handle one line Comments\n  if (stream.match(\"//\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle Number Literals\n  if (stream.match(/^[0-9\\.+-]/, false)) {\n    if (stream.match(/^[+-]?0x[0-9a-fA-F]+/))\n      return \"number\";\n    if (stream.match(/^[+-]?\\d*\\.\\d+([EeDd][+-]?\\d+)?/))\n      return \"number\";\n    if (stream.match(/^[+-]?\\d+([EeDd][+-]?\\d+)?/))\n      return \"number\";\n  }\n\n  // Handle Strings\n  if (stream.match(/^\"([^\"]|(\"\"))*\"/)) { return \"string\"; }\n  if (stream.match(/^'([^']|(''))*'/)) { return \"string\"; }\n\n  // Handle words\n  if (stream.match(keywords)) { return \"keyword\"; }\n  if (stream.match(identifiers)) { return \"variable\"; } ;\n\n  // Handle non-detected items\n  stream.next();\n  return null;\n};\n\nexport const protobuf = {\n  name: \"protobuf\",\n  token: tokenBase,\n  languageData: {\n    autocomplete: keywordArray\n  }\n}\n"],"names":["wordRegexp","words","RegExp","join","keywordArray","keywords","identifiers","tokenBase","stream","eatSpace","match","skipToEnd","next","protobuf","name","token","languageData","autocomplete"],"sourceRoot":""}