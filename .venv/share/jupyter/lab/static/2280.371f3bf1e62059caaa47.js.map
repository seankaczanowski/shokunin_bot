{"version":3,"file":"2280.371f3bf1e62059caaa47.js?v=371f3bf1e62059caaa47","mappings":"4KAAA,IAAIA,EAAe,4CACnB,IAAIC,EAAiB,uBACrB,IAAIC,EAAmB,oBAEvB,SAASC,EAASC,GAChB,OAAOC,WAAWD,GAAME,aAAeF,CACzC,CAEA,SAASG,EAAYC,GACnB,OAAO,SAASC,EAAQC,GACtB,IAAIC,EAAU,MAAOC,EACrB,OAAQA,EAAOH,EAAOG,SAAW,KAAM,CACrC,GAAIA,GAAQJ,IAAUG,EAAS,MAC/BA,GAAWA,GAAWC,GAAQ,IAChC,CAEA,IAAKD,EAASD,EAAMG,SAAWC,EAC/B,MAAO,QACT,CACF,CAEA,SAASC,EAAcC,GACrB,OAAO,SAASP,EAAQC,GACtB,GAAIM,GAAY,IACdP,EAAOQ,IAAI,WACR,GAAID,GAAY,IACnBP,EAAOQ,IAAI,MAEbP,EAAMG,SAAWC,EACjB,MAAO,UACT,CACF,CAEA,SAASI,EAAUC,GACjB,OAAO,SAASV,EAAQC,GACtB,IAAIN,EAAOe,EACX,OAAQA,EAAKV,EAAOW,SAAWD,EAAGE,MAAMrB,IAAiB,KAAM,CAC7DI,GAAQK,EAAOG,MACjB,CAEAF,EAAMG,SAAWC,EACjB,GAAIZ,EAAiBoB,KAAKlB,GACxB,MAAO,gBACJ,GAAID,EAASC,GAChB,MAAO,cACJ,GAAIK,EAAOW,QAAU,IACxB,MAAO,oBAEP,MAAO,QACX,CACF,CAEA,SAASN,EAAUL,EAAQC,GACzB,IAAIS,EAAKV,EAAOG,OAChB,GAAIO,GAAM,IACRT,EAAMG,SAAWN,EAAYY,QAC1B,GAAIlB,EAAeqB,KAAKH,GAC3BT,EAAMG,SAAWE,EAAcI,QAC5B,GAAInB,EAAasB,KAAKH,GACzBT,EAAMG,SAAWK,EAAUC,GAE7B,OAAQT,EAAMG,UAAYC,EAAaJ,EAAMG,SAASJ,EAAQC,GAAS,IACzE,CAEO,MAAMa,EAAO,CAClBC,KAAM,OAENC,WAAY,WACV,MAAO,CACLZ,SAAUC,EAEd,EAEAY,MAAO,SAASjB,EAAQC,GACtB,GAAID,EAAOkB,WAAY,OAAO,KAC9B,OAAOjB,EAAMG,SAASJ,EAAQC,EAChC,E","sources":["webpack://@jupyterlab/application-top/./node_modules/@codemirror/legacy-modes/mode/solr.js"],"sourcesContent":["var isStringChar = /[^\\s\\|\\!\\+\\-\\*\\?\\~\\^\\&\\:\\(\\)\\[\\]\\{\\}\\\"\\\\]/;\nvar isOperatorChar = /[\\|\\!\\+\\-\\*\\?\\~\\^\\&]/;\nvar isOperatorString = /^(OR|AND|NOT|TO)$/;\n\nfunction isNumber(word) {\n  return parseFloat(word).toString() === word;\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) break;\n      escaped = !escaped && next == \"\\\\\";\n    }\n\n    if (!escaped) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\n\nfunction tokenOperator(operator) {\n  return function(stream, state) {\n    if (operator == \"|\")\n      stream.eat(/\\|/);\n    else if (operator == \"&\")\n      stream.eat(/\\&/);\n\n    state.tokenize = tokenBase;\n    return \"operator\";\n  };\n}\n\nfunction tokenWord(ch) {\n  return function(stream, state) {\n    var word = ch;\n    while ((ch = stream.peek()) && ch.match(isStringChar) != null) {\n      word += stream.next();\n    }\n\n    state.tokenize = tokenBase;\n    if (isOperatorString.test(word))\n      return \"operator\";\n    else if (isNumber(word))\n      return \"number\";\n    else if (stream.peek() == \":\")\n      return \"propertyName\";\n    else\n      return \"string\";\n  };\n}\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"')\n    state.tokenize = tokenString(ch);\n  else if (isOperatorChar.test(ch))\n    state.tokenize = tokenOperator(ch);\n  else if (isStringChar.test(ch))\n    state.tokenize = tokenWord(ch);\n\n  return (state.tokenize != tokenBase) ? state.tokenize(stream, state) : null;\n}\n\nexport const solr = {\n  name: \"solr\",\n\n  startState: function() {\n    return {\n      tokenize: tokenBase\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    return state.tokenize(stream, state);\n  }\n};\n"],"names":["isStringChar","isOperatorChar","isOperatorString","isNumber","word","parseFloat","toString","tokenString","quote","stream","state","escaped","next","tokenize","tokenBase","tokenOperator","operator","eat","tokenWord","ch","peek","match","test","solr","name","startState","token","eatSpace"],"sourceRoot":""}