{"version":3,"file":"3372.b17a58624f0bdbd1ec91.js?v=b17a58624f0bdbd1ec91","mappings":"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","sources":["webpack://@jupyterlab/application-top/./node_modules/@codemirror/legacy-modes/mode/crystal.js"],"sourcesContent":["function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\n\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\n\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\n  \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n  \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n  \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n  \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n  \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n  \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\n  \"def\", \"fun\", \"macro\",\n  \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n  \"do\", \"for\"\n];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n};\nvar matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Macros\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  }\n\n  // Comments\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Variables and keywords\n  var matched;\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n\n    matched = stream.current();\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n\n    return \"variable\";\n  }\n\n  // Class variables and instance variables\n  // or attributes\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  }\n\n  // Constants and types\n  if (stream.match(types)) {\n    return \"tag\";\n  }\n\n  // Symbols or ':' operator\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) ||\n               stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n    stream.eat(\":\");\n    return \"operator\";\n  }\n\n  // Strings\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  }\n\n  // Strings or regexps or macro variables or '%' operator\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if(delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  }\n\n  // Here Docs\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n  }\n\n  // Characters\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  }\n\n  // Numbers\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n    return \"number\";\n  }\n\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  }\n\n  // Operators\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n    return \"operator\";\n  }\n\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  }\n\n  // Parens and braces\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  }\n\n  // Escapes\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n\n  stream.next();\n  return null;\n}\n\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n\n    var nextStyle = tokenBase(stream, state);\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n\n    return nextStyle;\n  };\n}\n\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n\n    return tokenBase(stream, state);\n  };\n}\n\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var matched;\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n    stream.eat(/[?!]/);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n\n        var ch = stream.next();\n\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return style;\n  };\n}\n\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace()\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n\n    var escaped = false;\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n\n        escaped = stream.next() == \"\\\\\" && embed;\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return \"string\";\n  }\n}\n\nexport const crystal = {\n  name: \"crystal\",\n  startState: function () {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n\n  token: function (stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n\n    return style;\n  },\n\n  indent: function (state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n\n    return cx.unit * state.currentIndent;\n  },\n\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"names":["wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywordsArray","indentKeywords","indentExpressionKeywordsArray","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","tokenFollowIdent","tokenMacroDef","tokenFollowType","matching","tokenBase","eatSpace","lastToken","match","tokenMacro","peek","skipToEnd","matched","eat","current","test","blocks","indexOf","currentIndent","lastStyle","pop","hasOwnProperty","tokenNest","tokenQuote","style","embed","delim","next","tokenHereDoc","begin","started","length","nextStyle","escaped","ch","phrase","sol","crystal","name","startState","token","indent","textAfter","cx","replace","unit","languageData","indentOnInput","concat","commentTokens","line"],"sourceRoot":""}