{"version":3,"file":"parse.js","names":["_debug","_interopRequireDefault","require","_fs","_jsYaml","_lodash","_core","_configUtils","e","__esModule","default","debug","buildDebug","parseConfigFile","configPath","fileExists","Error","test","yamlConfig","YAML","load","fs","readFileSync","strict","Object","assign","config_path","jsonConfig","code","message","APP_ERROR","CONFIG_NOT_VALID","fromJStoYAML","config","isObject","dump"],"sources":["../src/parse.ts"],"sourcesContent":["import buildDebug from 'debug';\nimport fs from 'fs';\nimport YAML from 'js-yaml';\nimport { isObject } from 'lodash';\n\nimport { APP_ERROR } from '@verdaccio/core';\nimport { ConfigYaml } from '@verdaccio/types';\n\nimport { fileExists } from './config-utils';\n\nconst debug = buildDebug('verdaccio:config:parse');\n\n/**\n * Parse a config file from yaml to JSON.\n * @param configPath the absolute path of the configuration file\n */\nexport function parseConfigFile(configPath: string): ConfigYaml & {\n  // @deprecated use configPath instead\n  config_path: string;\n  configPath: string;\n} {\n  debug('parse config file %s', configPath);\n  if (!fileExists(configPath)) {\n    throw new Error(`config file does not exist or not reachable`);\n  }\n  debug('parsing config file: %o', configPath);\n  try {\n    if (/\\.ya?ml$/i.test(configPath)) {\n      const yamlConfig = YAML.load(fs.readFileSync(configPath, 'utf8'), {\n        strict: false,\n      }) as ConfigYaml;\n\n      return Object.assign({}, yamlConfig, {\n        configPath,\n        // @deprecated use configPath instead\n        config_path: configPath,\n      });\n    }\n\n    const jsonConfig = require(configPath) as ConfigYaml;\n    return Object.assign({}, jsonConfig, {\n      configPath,\n      // @deprecated use configPath instead\n      config_path: configPath,\n    });\n  } catch (e: any) {\n    if (e.code !== 'MODULE_NOT_FOUND') {\n      debug('config module not found %o error: %o', configPath, e.message);\n      throw Error(APP_ERROR.CONFIG_NOT_VALID);\n    }\n\n    throw e;\n  }\n}\n\nexport function fromJStoYAML(config: Partial<ConfigYaml>): string | null {\n  debug('convert config from JSON to YAML');\n  if (isObject(config)) {\n    return YAML.dump(config);\n  } else {\n    throw new Error(`config is not a valid object`);\n  }\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,MAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,GAAA,GAAAF,sBAAA,CAAAC,OAAA;AACA,IAAAE,OAAA,GAAAH,sBAAA,CAAAC,OAAA;AACA,IAAAG,OAAA,GAAAH,OAAA;AAEA,IAAAI,KAAA,GAAAJ,OAAA;AAGA,IAAAK,YAAA,GAAAL,OAAA;AAA4C,SAAAD,uBAAAO,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAE5C,MAAMG,KAAK,GAAG,IAAAC,cAAU,EAAC,wBAAwB,CAAC;;AAElD;AACA;AACA;AACA;AACO,SAASC,eAAeA,CAACC,UAAkB,EAIhD;EACAH,KAAK,CAAC,sBAAsB,EAAEG,UAAU,CAAC;EACzC,IAAI,CAAC,IAAAC,uBAAU,EAACD,UAAU,CAAC,EAAE;IAC3B,MAAM,IAAIE,KAAK,CAAC,6CAA6C,CAAC;EAChE;EACAL,KAAK,CAAC,yBAAyB,EAAEG,UAAU,CAAC;EAC5C,IAAI;IACF,IAAI,WAAW,CAACG,IAAI,CAACH,UAAU,CAAC,EAAE;MAChC,MAAMI,UAAU,GAAGC,eAAI,CAACC,IAAI,CAACC,WAAE,CAACC,YAAY,CAACR,UAAU,EAAE,MAAM,CAAC,EAAE;QAChES,MAAM,EAAE;MACV,CAAC,CAAe;MAEhB,OAAOC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEP,UAAU,EAAE;QACnCJ,UAAU;QACV;QACAY,WAAW,EAAEZ;MACf,CAAC,CAAC;IACJ;IAEA,MAAMa,UAAU,GAAGzB,OAAO,CAACY,UAAU,CAAe;IACpD,OAAOU,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEE,UAAU,EAAE;MACnCb,UAAU;MACV;MACAY,WAAW,EAAEZ;IACf,CAAC,CAAC;EACJ,CAAC,CAAC,OAAON,CAAM,EAAE;IACf,IAAIA,CAAC,CAACoB,IAAI,KAAK,kBAAkB,EAAE;MACjCjB,KAAK,CAAC,sCAAsC,EAAEG,UAAU,EAAEN,CAAC,CAACqB,OAAO,CAAC;MACpE,MAAMb,KAAK,CAACc,eAAS,CAACC,gBAAgB,CAAC;IACzC;IAEA,MAAMvB,CAAC;EACT;AACF;AAEO,SAASwB,YAAYA,CAACC,MAA2B,EAAiB;EACvEtB,KAAK,CAAC,kCAAkC,CAAC;EACzC,IAAI,IAAAuB,gBAAQ,EAACD,MAAM,CAAC,EAAE;IACpB,OAAOd,eAAI,CAACgB,IAAI,CAACF,MAAM,CAAC;EAC1B,CAAC,MAAM;IACL,MAAM,IAAIjB,KAAK,CAAC,8BAA8B,CAAC;EACjD;AACF","ignoreList":[]}