/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
import { showDialog } from '@jupyterlab/apputils';
import { nullTranslator } from '@jupyterlab/translation';
import { ReactWidget, updateFilterFunction, UseSignal } from '@jupyterlab/ui-components';
import { Signal } from '@lumino/signaling';
import { SplitPanel } from '@lumino/widgets';
import React from 'react';
import { PluginList } from './pluginlist';
import { SettingsPanel } from './settingspanel';
/**
 * Form based interface for editing settings.
 */
export class SettingsEditor extends SplitPanel {
    constructor(options) {
        super({
            orientation: 'horizontal',
            renderer: SplitPanel.defaultRenderer,
            spacing: 1
        });
        this._clearDirty = null;
        this._dirty = false;
        this._saveStateChange = new Signal(this);
        this.translator = options.translator || nullTranslator;
        this._status = options.status;
        this._listModel = new PluginList.Model({
            registry: options.registry,
            // Filters out a couple of plugins that take too long to load in the new settings editor.
            toSkip: options.toSkip
        });
        this._list = new PluginList({
            registry: options.registry,
            translator: this.translator,
            query: options.query,
            model: this._listModel
        });
        this._listModel.changed.connect(() => {
            this.update();
        });
        this.addWidget(this._list);
        this.setDirtyState = this.setDirtyState.bind(this);
        const settingsPanel = ReactWidget.create(React.createElement(UseSignal, { signal: this._listModel.changed }, () => (React.createElement(SettingsPanel, { settings: [...Object.values(this._listModel.settings)], editorRegistry: options.editorRegistry, handleSelectSignal: this._list.handleSelectSignal, onSelect: (id) => (this._list.selection = id), hasError: this._list.setError, updateFilterSignal: this._list.updateFilterSignal, updateDirtyState: this.setDirtyState, translator: this.translator, initialFilter: this._list.filter }))));
        // Initializes the settings panel after loading the schema for all plugins.
        this._listModel.ready
            .then(() => {
            this.addWidget(settingsPanel);
        })
            .catch(reason => {
            console.error(`Failed to load the setting plugins:\n${reason}`);
        });
    }
    /**
     * A signal emitted on the start and end of a saving operation.
     */
    get saveStateChanged() {
        return this._saveStateChange;
    }
    /**
     * Set the dirty state status
     *
     * @param dirty New status
     */
    setDirtyState(dirty) {
        this._dirty = dirty;
        if (this._dirty && !this._clearDirty) {
            this._clearDirty = this._status.setDirty();
        }
        else if (!this._dirty && this._clearDirty) {
            this._clearDirty.dispose();
            this._clearDirty = null;
        }
        if (dirty) {
            if (!this.title.className.includes('jp-mod-dirty')) {
                this.title.className += ' jp-mod-dirty';
            }
        }
        else {
            this.title.className = this.title.className.replace('jp-mod-dirty', '');
        }
        this._saveStateChange.emit(dirty ? 'started' : 'completed');
    }
    /**
     * Updates the filter of the plugin list.
     *
     * @param query The query to filter the plugin list
     */
    updateQuery(query) {
        this._list.setFilter(query ? updateFilterFunction(query, false, false) : null, query);
    }
    /**
     * A message handler invoked on a `'close-request'` message.
     *
     * @param msg Widget message
     */
    onCloseRequest(msg) {
        const trans = this.translator.load('jupyterlab');
        if (this._list.hasErrors) {
            void showDialog({
                title: trans.__('Warning'),
                body: trans.__('Unsaved changes due to validation error. Continue without saving?')
            }).then(value => {
                if (value.button.accept) {
                    this.dispose();
                    super.onCloseRequest(msg);
                }
            });
        }
        else if (this._dirty) {
            void showDialog({
                title: trans.__('Warning'),
                body: trans.__('Some changes have not been saved. Continue without saving?')
            }).then(value => {
                if (value.button.accept) {
                    this.dispose();
                    super.onCloseRequest(msg);
                }
            });
        }
        else {
            this.dispose();
            super.onCloseRequest(msg);
        }
    }
}
//# sourceMappingURL=settingseditor.js.map